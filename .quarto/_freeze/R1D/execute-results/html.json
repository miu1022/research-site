{
  "hash": "ef05652cfb2be0b296b203b2a5fcfd4d",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"R1D\"\nauthor: \"ryoke\"\nformat:\n  html:\n    theme: cosmo\n    ##css: styles.css\n    toc: true\n    toc-depth: 3\n    code-fold: false\nproject:\n  output-dir: docs    \neditor: visual\n---\n\n# R1D関数はどんな関数か\n\n#### ランク1テンソルを再構成する関数\n\n## ランク1テンソル\n\nN個のベクトルの外積\n\n$$\n\\boldsymbol{a}_{1}\\circ\\boldsymbol{a}_{2}\\circ\\cdots\\boldsymbol{a}_{N}\n$$\n\n![ランク1テンソルのダイアグラム表示](image/R1D(1).png){width=\"8%\"}\n\n## ランク1テンソルの作成方法\n\n[要素1のN階テンソル$\\mathbf{\\mathcal{X}}\\in\\mathbb{R}^{1\\times1\\times \\cdots \\times1}$に対して，ベクトル$\\{\\boldsymbol{a}_{1},\\boldsymbol{a}_{2},\\cdots,\\boldsymbol{a}_{N}\\}$を逐次的に外積する.]{style=\"color:#FF6347\"}\n\n::: callout-note\n外積：ベクトルを並べる操作\n\nつまり，バラバラの状態の$\\{\\boldsymbol{a}_{1},\\boldsymbol{a}_{2},\\cdots,\\boldsymbol{a}_{N}\\}$を並べると，$\\boldsymbol{a}_{1}\\circ\\boldsymbol{a}_{2}\\circ\\cdots\\boldsymbol{a}_{N}$になる.\n:::\n\n⇒`TMall`を使う\n\n-   外積なのに何故？\n\n　[$\\mathbf{\\mathcal{X}}$と$\\{\\boldsymbol{a}\\}$の全モード積をとっているとも考えられるから]{style=\"color:#FF6347\"}\n\n### $\\mathbf{\\mathcal{X}}$と$\\{\\boldsymbol{a}\\}$の全モード積\n\n-   $N$階テンソル$\\mathbf{\\mathcal{X}}$について\n\n$N$個のベクトルの外積と捉える<br><br>\n\n![$\\mathbf{\\mathcal{X}}$のダイアグラム](image/R1D(2).png){width=\"25%\" fig-align=\"left\"}\n\n大きさ1のベクトル（スカラー）が$N$個\n\n全体で見るとスカラーなので脚は無し\n\n![$\\mathbf{\\mathcal{X}}$のダイアグラム](image/R1D(3).png){width=\"25%\" fig-align=\"left\"}\n\n-   $N$個のベクトル$\\{\\boldsymbol{a}_{1},\\boldsymbol{a}_{2},\\cdots,\\boldsymbol{a}_{N}\\}$について\n\nベクトルが$N$個.\n\nまだ並んではいない\n\n![$\\boldsymbol{a}_{n}$](image/R1D(4).png){width=\"3%\" fig-align=\"left\"}\n\n#### 全モード積を計算\n\n$\\mathbf{\\mathcal{X}}$と$\\{\\boldsymbol{a}\\}$の全モード積\n\n![全モード積のイメージ](image/R1D(5).png){width=\"25%\" fig-align=\"left\"}\n\n::: callout-note\nQ. どこを繋げるのか.\n\nA.サイズ1の脚（mode）どうし <br>    ベクトルはサイズ$(I_{n}\\times1)$スカラーはサイズ1と考える\n\n![ベクトル（左）スカラー（右） サイズ1の脚（赤色）](image/R1D(6).png){width=\"25%\" fig-align=\"left\"}\n:::\n\n<br>  サイズ1の脚どうしを繋ぐと\n\n![](image/R1D(7).png){width=\"25%\" fig-align=\"left\"}       ベクトルになった\n\n##### これを全モードについて行うと，\n\n<br><br>\n\n![](image/R1D(8).png){width=\"70%\"} <br> ランク１テンソルの完成！ <br><br>\n\n#### [ランク1テンソルの作成方法：要素1のN階テンソル$\\mathbf{\\mathcal{X}}\\in\\mathbb{R}^{1\\times1\\times \\cdots \\times1}$とベクトル$\\{\\boldsymbol{a}_{1},\\boldsymbol{a}_{2},\\cdots,\\boldsymbol{a}_{N}\\}$の全モード積をとる.]{style=\"color:#DC143C\"}\n\n⇒`TMall`\n\n# Rコードを作成\n\n## R1D関数を使わずにランク1テンソルを作成\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"E:/home/ryoke/workspace/R/テンソルデータ解析の基礎と応用/test\"\n```\n\n\n:::\n:::\n\n\n### 1. 要素が1のテンソルを作成\n\n3階テンソル$\\mathbf{\\mathcal{G}}\\in\\mathbb{R}^{1\\times1\\times1}$\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnRank <- 3\n\nshape <- rep(1,nRank)\n\nG <- array(1  ## 全要素1\n           ,shape)\n```\n:::\n\n\n最初に階数`nRank`を設定\n\nサイズ`shape`は、1を階数個分繰り返す\n\n#### 計算用のオブジェクトにコピー\n\n\n::: {.cell}\n\n```{.r .cell-code}\nX <- G\n```\n:::\n\n\n#### 確認\n\n-   要素1の$\\mathbf{\\mathcal{X}}\\in\\mathbb{R}^{1\\times1\\times1}$\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(X)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n, , 1\n\n     [,1]\n[1,]    1\n```\n\n\n:::\n:::\n\n\n-   サイズが$(1\\times1\\times1)$\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(shape)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 1 1\n```\n\n\n:::\n:::\n\n\n### 2. ベクトルのリストを作成\n\nベクトルの集合$\\{\\boldsymbol{a}\\}$\n\n行列型で作成する\n\n#### 領域確保\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlistA <- NULL\n```\n:::\n\n\n#### `listA`にベクトルを格納していく\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor(n in c(1:nRank)){\n  le <- n+1  ## ベクトルごとに列数を変える\n  \n  ## 行列型で生成\n  ## 要素の値も確認したいので，簡単な要素にした。2025/04/17\n  A_n <- matrix(c(1:le) \n               , ncol = 1)  \n  \n  listA[[n]] <- A_n\n}\n```\n:::\n\n\n#### 確認\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(listA)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n     [,1]\n[1,]    1\n[2,]    2\n\n[[2]]\n     [,1]\n[1,]    1\n[2,]    2\n[3,]    3\n\n[[3]]\n     [,1]\n[1,]    1\n[2,]    2\n[3,]    3\n[4,]    4\n```\n\n\n:::\n:::\n\n\n### 3. テンソルにベクトルを外積していく\n\nテンソル$\\mathbf{\\mathcal{X}}$と$\\{\\boldsymbol{a}\\}$\n\n\n::: {.cell}\n\n```{.r .cell-code}\nX1 <-  TMall(Tensor = X\n             , listA = listA\n             , .isDebug = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n[1] 1 1 1\n     [,1]\n[1,]    1\n[2,]    2\n[1] 1 1 1\n[1] 2\n[1] 2 1\n[1] 1 1\n[1] 2 1\n     [,1]\n[1,]    1\n[2,]    2\n[3,]    3\n[1] 2 1 1\n[1] 3\n[1] 3 1\n[1] 1 2\n[1] 3 2\n     [,1]\n[1,]    1\n[2,]    2\n[3,]    3\n[4,]    4\n[1] 2 3 1\n[1] 4\n[1] 4 1\n[1] 1 6\n[1] 4 6\n```\n\n\n:::\n:::\n\n\n#### 確認\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(X1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n, , 1\n\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    2    4    6\n\n, , 2\n\n     [,1] [,2] [,3]\n[1,]    2    4    6\n[2,]    4    8   12\n\n, , 3\n\n     [,1] [,2] [,3]\n[1,]    3    6    9\n[2,]    6   12   18\n\n, , 4\n\n     [,1] [,2] [,3]\n[1,]    4    8   12\n[2,]    8   16   24\n```\n\n\n:::\n\n```{.r .cell-code}\ndim(X1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2 3 4\n```\n\n\n:::\n:::\n\n\n`X1`のサイズが`listA`の各要素のサイズと一致\n\n## R1D関数のコード\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# R1D関数  ---------------------------------------------------------------------\n\nR1D <- function(listA){\n  \n  ## 因子ベクトル{lista}の個数\n  N <- length(listA)\n  \n  ## N階テンソルX1の作成\n  X1 <- array(1,rep(1,N))\n  \n  ## X1と{a}の全モード積を計算\n  X <- TMall(X1,listA)\n  \n  return(X)\n}\n```\n:::\n\n\n-   引数：ベクトル$\\{\\boldsymbol{a}\\}$（ベクトル（行列型）のリスト）\n\n-   N階テンソル$\\mathbf{\\mathcal{X}}\\in\\mathbb{R}^{1\\times1\\times \\cdots \\times1}$は，関数内で生成した. （関数外の方が良い？）\n\n    -   サイズ（shape）:`rep(1,N)`1をN回繰り返す.\n\n## R1D関数を使ってランク１テンソルを作成\n\n引数:`listA`\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n     [,1]\n[1,]    1\n[2,]    2\n\n[[2]]\n     [,1]\n[1,]    1\n[2,]    2\n[3,]    3\n\n[[3]]\n     [,1]\n[1,]    1\n[2,]    2\n[3,]    3\n[4,]    4\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nX2 <- R1D(listA = listA)\n```\n:::\n\n\n#### 確認\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndim(X2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2 3 4\n```\n\n\n:::\n:::\n\n\n#### 同一性の確認\n\n\n::: {.cell}\n\n```{.r .cell-code}\nall.equal(X1,X2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n⇒R1D関数は正しく動いた.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}